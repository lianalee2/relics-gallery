# 文物管理系统功能模块汇报素材

## 功能模块1：文物详情查询

### 交互逻辑（前端+后端）
用户在浏览页面点击文物卡片后，前端通过URL参数传递文物ID（如`/artifact/123`）。Flask路由处理函数`detail()`接收artifact_id参数，通过数据库查询获取文物的完整信息，包括基本信息、属性信息（文化、地理、艺术家等）、来源机构、所有图片以及尺寸信息。最后将数据传递给模板引擎渲染详情页面。

### 核心 SQL 实现（数据库）

#### 主信息查询（多表JOIN）
```sql
SELECT 
    a.Artifact_PK AS artifact_id,
    a.Source_ID AS source_id,
    a.Original_ID AS original_id,
    a.Title_CN AS title,
    a.Title_EN AS title_en,
    a.Description_CN AS description,
    a.Classification AS classification,
    a.Material AS medium,
    a.Date_CN AS date_text,
    a.Date_EN AS date_en,
    p.Geography AS geography,
    p.Culture AS culture_name,
    p.Artist AS artist_name,
    p.Credit_Line AS credit_text,
    p.Page_Link AS source_url,
    s.Museum_Name_CN AS dept_name
FROM ARTIFACTS a
LEFT JOIN PROPERTIES p ON a.Artifact_PK = p.Artifact_PK
LEFT JOIN SOURCES s ON a.Source_ID = s.Source_ID
WHERE a.Artifact_PK = ?
```

**设计要点**：
- 使用`LEFT JOIN`确保即使属性信息缺失也能获取文物基本信息
- 通过外键关联`ARTIFACTS`表与`PROPERTIES`、`SOURCES`表，实现数据的规范化存储
- `WHERE`子句使用主键查询，确保查询效率（索引优化）

#### 图片列表查询
```sql
SELECT Local_Path AS local_path
FROM IMAGE_VERSIONS
WHERE Artifact_PK = ?
ORDER BY Version_PK
```

**设计要点**：
- 一张文物可有多张图片，通过`IMAGE_VERSIONS`表实现一对多关系
- `ORDER BY Version_PK`保证图片显示顺序的一致性

#### 尺寸信息查询
```sql
SELECT Size_Type, Size_Value, Size_Unit
FROM DIMENSIONS
WHERE Artifact_PK = ?
ORDER BY Dimension_PK
```

**设计要点**：
- 使用独立表存储尺寸信息，支持同一文物有多个维度（长度、宽度、高度等）
- 通过`Size_Type`区分不同维度的类型，提高数据表达的灵活性

---

## 功能模块2：多维度搜索功能

### 交互逻辑（前端+后端）
用户在搜索框输入关键词，前端通过GET请求将搜索词传递给Flask后端。后端接收搜索参数后，调用`build_search_query()`动态构建SQL查询语句。查询支持在标题、描述、文化字段中进行模糊匹配（LIKE），并可选择性地添加年代范围筛选。查询结果按相关度或用户选择的排序方式返回，前端以卡片网格形式展示。

### 核心 SQL 实现（数据库）

#### 基础搜索查询（多字段模糊匹配）
```sql
SELECT 
    a.Artifact_PK AS artifact_id, 
    a.Title_CN AS title, 
    a.Date_CN AS date_text,
    ANY_VALUE(iv.Local_Path) AS local_path,
    ANY_VALUE(p.Culture) AS culture_name,
    ANY_VALUE(a.Material) AS medium
FROM ARTIFACTS a
LEFT JOIN IMAGE_VERSIONS iv ON a.Artifact_PK = iv.Artifact_PK
LEFT JOIN PROPERTIES p ON a.Artifact_PK = p.Artifact_PK
WHERE (
    a.Title_CN LIKE ? 
    OR a.Description_CN LIKE ? 
    OR p.Culture LIKE ?
)
GROUP BY a.Artifact_PK 
ORDER BY a.Artifact_PK DESC
```

**设计要点**：
- 使用`OR`条件实现多字段全文搜索，扩大检索范围
- `LIKE`操作符配合通配符`%keyword%`实现模糊匹配
- `ANY_VALUE()`聚合函数用于处理GROUP BY后的非聚合字段（MySQL 5.7+要求）
- `GROUP BY`避免因多张图片导致结果重复

#### 东方朝代特殊处理（避免年代误判）
```sql
-- 宋代筛选（针对东方纪年）
AND a.Date_CN LIKE '%宋%'

-- 清代筛选（包含年号）
AND (a.Date_CN LIKE '%清%' 
     OR a.Date_CN LIKE '%康熙%' 
     OR a.Date_CN LIKE '%乾隆%' 
     OR a.Date_CN LIKE '%雍正%')
```

**设计要点**：
- 对于东方朝代，使用文字匹配而非数字年份，避免朝代信息的误判
- 针对清代，额外匹配年号关键词，提高检索准确度

#### 西方年代区间筛选
```sql
AND a.Start_Year BETWEEN ? AND ?
```

**设计要点**：
- 使用`BETWEEN`操作符进行范围查询，性能优于多个`OR`条件
- 利用`Start_Year`字段上的索引加速查询

---

## 功能模块3：文化浏览功能

### 交互逻辑（前端+后端）
用户访问文化浏览页面时，Flask后端查询所有文化分类及其统计信息。查询通过聚合函数统计每个文化下的文物数量，并选择一张代表性图片作为封面。前端以网格布局展示各个文化卡片，点击后进入该文化的文物列表页面。

### 核心 SQL 实现（数据库）

#### 文化列表查询（聚合统计）
```sql
SELECT 
    p.Culture AS culture_name,
    COUNT(DISTINCT a.Artifact_PK) AS artifact_count,
    ANY_VALUE(iv.Local_Path) AS representative_image
FROM PROPERTIES p
LEFT JOIN ARTIFACTS a ON p.Artifact_PK = a.Artifact_PK
LEFT JOIN IMAGE_VERSIONS iv ON a.Artifact_PK = iv.Artifact_PK
WHERE p.Culture IS NOT NULL AND p.Culture != ''
GROUP BY p.Culture
HAVING artifact_count > 0
ORDER BY artifact_count DESC, p.Culture
```

**设计要点**：
- `COUNT(DISTINCT a.Artifact_PK)`统计每个文化下的唯一文物数量，避免重复计数
- `HAVING artifact_count > 0`过滤掉没有文物的文化分类，优化展示效果
- `ORDER BY artifact_count DESC`按文物数量降序排列，突出热门文化
- `ANY_VALUE()`用于从多张图片中选择一张作为代表图

#### 文化下文物列表查询
```sql
SELECT 
    a.Artifact_PK AS artifact_id,
    a.Title_CN AS title,
    a.Date_CN AS date_text,
    ANY_VALUE(iv.Local_Path) AS local_path
FROM ARTIFACTS a
LEFT JOIN PROPERTIES p ON a.Artifact_PK = p.Artifact_PK
LEFT JOIN IMAGE_VERSIONS iv ON a.Artifact_PK = iv.Artifact_PK
WHERE p.Culture = ?
GROUP BY a.Artifact_PK
ORDER BY a.Artifact_PK DESC
```

**设计要点**：
- 通过`WHERE p.Culture = ?`精确匹配文化名称
- 使用参数化查询防止SQL注入
- `GROUP BY`确保每个文物只返回一条记录

---

## 功能模块4：时代浏览功能（东方/西方纪年）

### 交互逻辑（前端+后端）
用户选择东方纪年或西方纪年后，后端从数据库获取所有文物的年代信息，通过Python逻辑将年代文本（如"宋"、"19世纪"）转换为标准化的时代分类（如"宋"、"近代"）。系统按时代桶分组统计文物数量，并选择代表性图片。前端展示各个时代分类卡片，点击后显示该时代下的所有文物。

### 核心 SQL 实现（数据库）

#### 时代分组查询（获取所有文物年代）
```sql
SELECT
    a.Artifact_PK,
    a.Date_CN AS date_text,
    ANY_VALUE(iv.Local_Path) AS representative_image
FROM ARTIFACTS a
LEFT JOIN IMAGE_VERSIONS iv ON a.Artifact_PK = iv.Artifact_PK
WHERE a.Date_CN IS NOT NULL AND a.Date_CN != ''
GROUP BY a.Artifact_PK
```

**设计要点**：
- 在应用层进行年代文本的智能解析（Python函数`normalize_era_from_date_cn`），而非在数据库层，提高灵活性
- 数据库只负责提供原始年代数据，业务逻辑与数据层分离

#### 时代详情页查询（过滤特定时代）
```sql
SELECT
    a.Artifact_PK AS artifact_id,
    a.Title_CN AS title,
    a.Date_CN AS date_text,
    ANY_VALUE(iv.Local_Path) AS local_path
FROM ARTIFACTS a
LEFT JOIN IMAGE_VERSIONS iv ON a.Artifact_PK = iv.Artifact_PK
WHERE a.Date_CN IS NOT NULL AND a.Date_CN != ''
GROUP BY a.Artifact_PK
ORDER BY a.Artifact_PK DESC
```

**设计要点**：
- 在应用层进行二次过滤（根据`Date_CN`字段的值判断属于哪个时代分类）
- 这种设计虽然需要传输更多数据，但保证了时代分类逻辑的可维护性

---

## 功能模块5：随机浏览功能

### 交互逻辑（前端+后端）
用户点击"随机浏览"入口，Flask后端执行随机排序查询，从数据库中随机获取文物列表。前端以卡片网格形式展示，每次刷新都会得到不同的排序结果，提供探索性的浏览体验。

### 核心 SQL 实现（数据库）

#### 随机排序查询
```sql
SELECT 
    a.Artifact_PK AS artifact_id, 
    a.Title_CN AS title, 
    a.Date_CN AS date_text, 
    ANY_VALUE(iv.Local_Path) AS local_path
FROM ARTIFACTS a
LEFT JOIN IMAGE_VERSIONS iv ON a.Artifact_PK = iv.Artifact_PK
GROUP BY a.Artifact_PK
ORDER BY RAND()
```

**设计要点**：
- `ORDER BY RAND()`实现随机排序，每次查询结果顺序不同
- 注意：`RAND()`在大数据量下性能较差，但对于中等规模数据集（数千条）可以接受
- 若需优化，可考虑使用基于索引的随机采样（如`ORDER BY RAND() LIMIT 100`先随机采样再排序）

---

## 功能模块6：用户注册与登录

### 交互逻辑（前端+后端）
用户在前端填写邮箱、密码、用户名（可选）后提交注册表单。Flask后端验证输入格式（邮箱格式、密码长度），检查邮箱是否已注册。若通过验证，使用Werkzeug的`generate_password_hash()`对密码进行哈希加密后存入数据库。登录时，用户输入邮箱和密码，后端通过`check_password_hash()`比对哈希值，验证通过后创建Session会话。

### 核心 SQL 实现（数据库）

#### 用户注册（INSERT操作）
```sql
INSERT INTO Users (email, password_hash, username)
VALUES (?, ?, ?)
```

**设计要点**：
- `email`字段设置为`UNIQUE`约束，防止重复注册
- 密码以哈希值存储，不使用明文，符合安全规范
- 使用参数化查询（`?`占位符），防止SQL注入攻击

#### 用户登录验证（SELECT操作）
```sql
SELECT * FROM Users WHERE email = ?
```

**设计要点**：
- 通过邮箱唯一性快速定位用户（邮箱字段应建立索引）
- 密码验证在应用层完成，数据库只负责提供存储的哈希值
- 返回完整用户信息供后续Session使用

---

## 功能模块7：图集管理功能

### 交互逻辑（前端+后端）
用户可以在个人中心创建图集（相册），并为图集设置名称和公开/私密属性。在文物详情页，用户可以将文物添加到指定图集。后端通过`Collections`关联表记录图集与文物的多对多关系。用户可以在图集详情页查看所有收藏的文物，支持移除操作。

### 核心 SQL 实现（数据库）

#### 创建图集（INSERT操作）
```sql
INSERT INTO Albums (user_id, name, is_public)
VALUES (?, ?, ?)
```

**设计要点**：
- `user_id`外键关联到`Users`表，保证数据完整性
- `is_public`布尔字段控制图集的可见性

#### 获取用户图集列表（带统计信息和封面图）
```sql
SELECT a.*, 
       COUNT(DISTINCT c.collection_id) as item_count,
       (SELECT iv.Local_Path 
        FROM Collections c2
        INNER JOIN ARTIFACTS art ON c2.artifact_id = art.Artifact_PK
        LEFT JOIN IMAGE_VERSIONS iv ON art.Artifact_PK = iv.Artifact_PK
        WHERE c2.album_id = a.album_id 
          AND iv.Local_Path IS NOT NULL 
          AND iv.Local_Path != ''
        ORDER BY c2.created_at DESC
        LIMIT 1) as cover_image
FROM Albums a
LEFT JOIN Collections c ON a.album_id = c.album_id
WHERE a.user_id = ?
GROUP BY a.album_id
ORDER BY a.created_at DESC
```

**设计要点**：
- 使用相关子查询获取封面图片（最新添加的文物的第一张图片）
- `LEFT JOIN Collections`确保即使空图集也能显示
- `COUNT(DISTINCT c.collection_id)`统计图集中的文物数量
- `GROUP BY a.album_id`对每个图集进行聚合

#### 添加文物到图集（防重复插入）
```sql
-- 首先检查是否已存在
SELECT collection_id FROM Collections 
WHERE album_id = ? AND artifact_id = ?
LIMIT 1

-- 如果不存在，则插入
INSERT INTO Collections (album_id, artifact_id)
VALUES (?, ?)
```

**设计要点**：
- 使用先查询后插入的模式，避免重复收藏（幂等性设计）
- 可以优化为使用`INSERT IGNORE`或`ON DUPLICATE KEY UPDATE`（如果设置了唯一约束）

#### 获取图集中的文物列表
```sql
SELECT 
    a.Artifact_PK AS artifact_id,
    a.Title_CN AS title,
    a.Date_CN AS date_text,
    ANY_VALUE(iv.Local_Path) AS local_path,
    MIN(c.created_at) AS created_at
FROM Collections c
INNER JOIN ARTIFACTS a ON c.artifact_id = a.Artifact_PK
LEFT JOIN IMAGE_VERSIONS iv ON a.Artifact_PK = iv.Artifact_PK
WHERE c.album_id = ?
GROUP BY a.Artifact_PK, a.Title_CN, a.Date_CN
ORDER BY MIN(c.created_at) ASC
```

**设计要点**：
- 使用`INNER JOIN`确保只返回有效的文物记录
- `ORDER BY MIN(c.created_at) ASC`按添加时间正序排列，展示收藏历史
- `MIN(c.created_at)`处理同一文物多次添加的情况（实际中应通过唯一约束避免）

---

## 功能模块8：管理员仪表板

### 交互逻辑（前端+后端）
管理员登录后访问仪表板，Flask后端执行多个统计查询，获取系统总体数据（文物总数、图片总数、来源机构数等）以及最近操作日志。数据通过聚合查询和子查询获取，最终以仪表板形式展示给管理员。

### 核心 SQL 实现（数据库）

#### 统计信息查询（多个独立查询）
```sql
-- 文物总数
SELECT COUNT(*) as count FROM ARTIFACTS

-- 图片总数
SELECT COUNT(*) as count FROM IMAGE_VERSIONS

-- 来源机构数
SELECT COUNT(*) as count FROM SOURCES

-- 最近7天新增文物（从日志表统计）
SELECT COUNT(*) as count 
FROM LOGS 
WHERE Table_Name = 'ARTIFACTS' 
  AND Operation_Type = 'INSERT' 
  AND Log_Time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
```

**设计要点**：
- 使用`COUNT(*)`进行快速计数，利用索引优化查询性能
- `DATE_SUB(NOW(), INTERVAL 7 DAY)`实现时间范围过滤
- 通过`LOGS`表记录操作历史，支持审计和统计分析

#### 按来源机构统计文物数量
```sql
SELECT s.Museum_Name_CN, COUNT(a.Artifact_PK) as count
FROM SOURCES s
LEFT JOIN ARTIFACTS a ON s.Source_ID = a.Source_ID
GROUP BY s.Source_ID
ORDER BY count DESC
```

**设计要点**：
- 使用`LEFT JOIN`确保所有来源机构都被统计（即使没有文物）
- `GROUP BY s.Source_ID`按来源分组统计
- `ORDER BY count DESC`按数量降序，突出主要数据来源

#### 最近操作日志查询
```sql
SELECT Log_PK, Log_Time, Table_Name, Operation_Type, 
       User_ID, Status, Description
FROM LOGS
ORDER BY Log_Time DESC
LIMIT 10
```

**设计要点**：
- `ORDER BY Log_Time DESC`按时间倒序，展示最新操作
- `LIMIT 10`限制返回记录数，避免前端渲染压力

---

## 功能模块9：批量数据导入功能

### 交互逻辑（前端+后端）
管理员上传CSV或Excel文件，Flask后端使用pandas读取文件内容，对列名进行标准化映射。后端逐行处理数据，调用存储过程`sp_import_artifact_metadata`执行导入。存储过程内部处理数据的插入或更新逻辑，并记录操作日志。导入完成后返回统计结果（新增、更新、跳过、失败的记录数）。

### 核心 SQL 实现（数据库）

#### 调用存储过程进行数据导入
```sql
CALL sp_import_artifact_metadata(
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
    ?, ?, ?,
    @p_artifact_id, @p_result_status, @p_result_message
)

-- 获取存储过程的OUT参数
SELECT @p_artifact_id as artifact_id, 
       @p_result_status as status, 
       @p_result_message as message
```

**设计要点**：
- 使用存储过程封装复杂的业务逻辑（检查重复、插入/更新决策等），减少网络往返
- 通过OUT参数返回处理结果，便于应用层判断操作状态
- 存储过程内部可包含事务处理，保证数据一致性

#### 记录导入错误日志（存储过程调用）
```sql
CALL sp_log_import_error(?, ?, ?, ?)
```

**设计要点**：
- 将错误记录单独存储，便于后续分析和修正
- 参数包括：文物标题、错误信息、操作用户、行号

---

## 数据库设计亮点总结

1. **规范化设计**：通过`PROPERTIES`、`DIMENSIONS`、`IMAGE_VERSIONS`等表将文物属性拆分，避免冗余，支持一对多关系
2. **索引优化**：主键、外键字段自动建立索引，提高JOIN和WHERE查询性能
3. **数据完整性**：通过外键约束保证关联数据的有效性
4. **日志审计**：`LOGS`表记录所有重要操作，支持数据追踪和审计
5. **存储过程封装**：复杂业务逻辑封装在数据库中，提高执行效率和可维护性

